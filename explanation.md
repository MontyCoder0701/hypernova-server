# 고민한 포인트 및 설계

## 1. 스케쥴의 구성

- `Schedule` 모델은 반복 일정의 기준 시간(`time`), 시작일(`start_datetime`), 종료일(`end_datetime`)을 포함한다.
- 요일 반복은 `ScheduleDay` 모델로 분리하여 관리하며, 정수 기반 `enum Weekday`를 활용해 일관성 있게 표현하였다.

## 2. 쉬어가기(Exclusion) 처리

- 특정 날짜에 일정을 건너뛰기 위한 구조로 `ScheduleExclusion` 모델을 정의하였다.
- `Schedule`과의 관계를 통해 쉬어가는 날짜를 명시적으로 연결할 수 있으며, 기존 반복 구조는 그대로 유지된다.

## 3. 하루 시간 변경(Time Modification) 처리

- 처음 하루의 시간 변경 요청 시 기존 `Schedule`을 종료시키고, 새 일정을 새로 생성하는 방식으로 처리하였다.
- 하지만 이 방식은 쉬어가기 처리와 충돌하였다. 새로운 일정을 생성하게 되면 **그 날 하루가 기존 `Schedule`과의 연결이 끊기므로, 해당 날짜에 설정된 쉬어가기 정보가
  반영되지 않게 된다.**
- 다시 말해, 단순히 시간을 변경하고 싶은 것임에도 새로운 일정이 생성되면 **그날의 모든 시간 설정과 예외 로직이 무효화**되는 문제가 발생한다.
- 따라서 설계를 변경하여, 시간 변경 역시 기존 `Schedule`의 일부로 간주하고 `ScheduleTimeModification` 모델을 통해 개별 날짜에 대한 시간만
  예외적으로 관리하는 방식으로 전환하였다.
- 이로 인해 시간 변경 역시 "일정에 귀속되어 처리되는 것"으로 해석되며, 쉬어가기와 공존할 수 있다.

## 4. 전체 스케쥴 변경 처리

- 전체 반복 시간이나 요일을 바꾸는 경우에는 기존 `Schedule`을 만료(`end_datetime` 설정)시키고, 새로운 `Schedule` 객체를 생성하여 이력을 보존하도록
  설계하였다.
- 새로 생성된 일정에는 이전 일정의 구조를 참조하여 필요한 데이터(요일, 시간, 예외 등)를 일부 복제하거나 초기화하여 적용한다.

## 5. 요일 관리

- `Weekday`라는 `IntEnum`을 정의하여 요일을 정수로 관리.
- enum을 통해 ORM 저장 시 정합성을 유지할 수 있으며, 추후 프론트엔드 연동 시에도 유리하다.

## 6. MySQL `TIME` vs Tortoise ORM `timedelta` 타입 불일치 및 `from_orm()` 활용

- `Tortoise ORM`의 `TimeField()`는 내부적으로 Python의 `datetime.time` 객체와 매핑되지만, ORM 외부에서는 `timedelta`와
  혼용되어 사용되는 경우가 있었다.
- 그러나 `MySQL`에서의 `TIME` 필드는 `HH:MM:SS` 형식으로 저장되며, 이는 **시간 간격(duration)** 으로 해석되기 때문에 `timedelta`와
  호환되는 것처럼 보인다.
- 하지만 실제로는 `timedelta`와 `datetime.time` 객체는 **직렬화 포맷이 다르고, 상호 비교 연산에서도 오류를 발생시킬 수 있다.**
- 이 문제로 인해 초기에 `timedelta`를 사용한 모델 설계는 FastAPI 응답 및 비교 연산에서 오류가 발생하였다.
- 이를 해결하기 위해, 일정 시간은 `datetime.time`으로 통일하고, 연산이 필요한 경우 `datetime.combine(date, time)`을 통해
  `datetime` 객체로 변환하여 처리하였다.
- 외부 응답에서는 Pydantic 모델의 `from_orm()` 메서드를 사용하여 Tortoise ORM 객체를 직렬화하였다.  
  이를 위해 각 DTO 모델에 `Config.orm_mode = True`를 선언하였고, 관계 모델이나 속성 접근이 가능하도록 구성하였다.
